##  Интересные факты из прошивки 

Boot прошивки для PY32F002A, PY32F003, PY32F030  совершенно одинаковые.<br>
Различие начинается в конфигурационной области адреса 0x1FFF0D80-0x1FFF0FFF

По порядку будем разбирать что удалось найти по анализу программы Bootloader<br>
(Адрес, Пример, Описание)

$\textsf{\color{blue}0x1FFF0D80-0x1FFF0D8F}$<br>
```
0x1FFF0D80: 32 33 59 50 33 30 30 46 44 34 32 4С 30 30 30 36 '23YP300FD42L0006'
```
Записан тип микроконтроллера по 4 байт, если развернуть  PY32F003L24D6000

для PY32F002AW15U6 - буква 'A' не будет записана
```
0x1FFF0D80: 32 33 59 50 32 30 30 46 55 35 31 57 30 30 30 36 '23YP200FU51W0006'
```
$\textsf{\color{red}// !!! в некоторых чипах - нет данных - заполнено 0xFF}$

$\textsf{\color{blue}0x1FFF0D90-0x1FFF0D9F}$
```
// для  PY32F003L24D6
0x1FFF0D90: 07 64 61 00 00 00 00 00 00 00 04 00 00 00 00 00  
// для  PY32F002AW15U6
0x1FFF0D90: FF 71 03 00 00 00 00 00 00 00 04 00 00 00 00 00  
```
8 halfword (16 bit) определяющих наличие выведенных портов!<br>
Порты A,B,C...H<br> 
```
для  PY32F003L24D6  получаем  
  0x6407  0b0110010000000111 - PA0,1,2,10,13,14
  0x0061  0b0000000001100001 - PB0,5,6
  0x0004  0b0000000000000100 - PF2
для  PY32F002AW15U6  получаем  
  0x71FF  0b0111000111111111 - PA0-8,12-14
  0x0003  0b0000000000000011 - PB0,1
  0x0004  0b0000000000000100 - PF2
```
Используется boot программой для настройки неиспользуемых портов.<br> 
Для загрузки по USART1 могут использоваться пары PA2,3  PA9,10  PA14,15<br>
Если данные потры не выведены на пины - включается Pull-Up на входы (PA3,10,15)<br>
Для исключения влияния на дальнейший опрос невыведенных портов!<br>
// !!! в некоторых чипах - нет данных - заполнено 0xFF


#### 0x1FFF0DA0-0x1FFF0DFF
???

#### 0x1FFF0E00-0x1FFF0E0F
UID - описание смотрим в RM & DS

#### 0x1FFF0E10-0x1FFF0E1F
???

#### 0x1FFF0E20-0x1FFF0E23
```
Vrefint 1.2V  correction value
  32 bit word: high 16 bit - value, low 16 bit - iverted value
0x1FFF0E20: 66 EE 99 11
value = 0x1199
```
// определяет реальное значение Vrefint закодированное BCD<br>
// если есть - в примере получается 1.199V<br>
// если не задано  (FF FF FF FF) то получается  Vrefint = 1.2V  

#### 0x1FFF0E24-0x1FFF0E3F
???

#### 0x1FFF0E40-0x1FFF0E53
Почти те же значения как и по адресу - 0x1FFF0F00<br> 
5 dword - калибровка частот HSI<br>
но значения чуть меньше<br> 
возможно это данные при другой температуре или напряжении питания?

#### 0x1FFF0E54-0x1FFF0E5B
Те же значения как и по адресу - 0x1FFF0F14<br> 
2 dword - калибровочные константы датчика температуры<br>
возможно это данные при другой температуре или напряжении питания?

#### 0x1FFF0E5C-0x1FFF0E7F
???

#### 0x1FFF0E80-0x1FFF0E8F
Option bytes - описание смотрим в RM & DS<br>
одинаковые начальные значения для всех контроллеров
```
0x1FFF0E80: AA BE 55 41 FF 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF
```

#### 0x1FFF0E90-0x1FFF0EFF
???

#### 0x1FFF0F00-0x1FFF0F13

- Калибровочные константы для HSI (5 dwords - 20 bytes)
```
0x1FFF0F00: 0000110C    @ HSI   4 MHz
0x1FFF0F04: 0000310B    @ HSI   8 MHz
0x1FFF0F08: 000052F4    @ HSI  16 MHz
0x1FFF0F0C: 00007307    @ HSI  22,12 MHz
0x1FFF0F10: 00009300    @ HSI  24 MHz
```
// на разных контроллерах значения немного отличаются <br> 
// в данных константах сразу закодирован какой HSI в старших 3-х битах!<br>
// для 24MHz - 0x9300 = 101_1001100000000 ( 0b101 - HSI 24MHz )

#### 0x1FFF0F14-0x1FFF0F1B

- Калибровочные константы для сенсора температуры
```
0x1FFF0F14: 0000310C    @  T = 30 C
0x1FFF0F18: 000052F2    @  T = 85 C
```

#### 0x1FFF0F1C-0x1FFF0F7F

- Калибровочные константы для Flash ( тайминги для разных HSI )<br>
  (5 x 5 = 25 dwords) описание смотрм DS и RM<br> 
Одинаковые значения на всех проверенных чипах


#### 0x1FFF0F80-0x1FFF0FA3
???

#### 0x1FFF0FA4-0x1FFF0FA7

- Калибровочная константа для LSI - dword ( 4 bytes )
```
0x1FFF0F14: FF1100EE    
значение - младшие 16 бит ( используется 9 бит в RCC_ICSCR )
старшие 16 бит - инверсия значения младших 16 бит.
``` 

#### 0x1FFF0FA8-0x1FFF0FFB
???

#### 0x1FFF0FFC-0x1FFF0FFF
```
// для  PY32F003L24  0x1FFF0FFC: 01 00 FE FF
// для  PY32F002AW15 0x1FFF0FFC: 13 00 EC FF
// для  PY32F003W16  0x1FFF0FFC: 13 00 EC FF
// для  PY32F030K28  0x1FFF0FFC: 37 00 C8 FF
  (используется 1 байт, 2-й равен 0, а 3 и 4 инверсия 1 и 2)
```
Закодирован размер RAM и Flash<br>
0x01 - 2K RAM 16K Flash<br>
0x13 - 4K RAM 32K Flash<br>
0x37 - 8K RAM 64K Flash

Первая цифра (bit[5:4])  0..3 - RAM     2,4,6,8K<br>
Вторая цифра (bit[2:0])  0..7 - Flash   8,16,24,32,40,48,56,64K

Как видим закодировать 20K/3K - невозможно для F002A и действительно используется 32K/4K !!

### Комментарии

Для запуска bootloader-а требуется вывод BOOT0 (только в корпусах от 20pin)<br>
На PY32F030K28T - запустилось только на PA14,15 (PY32CubeProgrammer)<br>
хотя приотитет по программе PA2,3 и PA9,10 - выше

